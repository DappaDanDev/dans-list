import { loggers } from '../../src/lib/utils/logger';

const logger = loggers.envio;

// Event handler types (these would be generated by Envio)
interface EventContext {
  Agent: {
    upsert: (data: AgentUpdate) => Promise<void>;
    get: (id: string) => Promise<Agent | null>;
  };
  ListingEvent: {
    create: (data: ListingEventData) => Promise<void>;
  };
  PurchaseEvent: {
    create: (data: PurchaseEventData) => Promise<void>;
  };
  MarketplaceFeeEvent: {
    create: (data: MarketplaceFeeEventData) => Promise<void>;
  };
  FundsWithdrawnEvent: {
    create: (data: FundsWithdrawnEventData) => Promise<void>;
  };
  MarketMetrics: {
    upsert: (data: MarketMetricsUpdate) => Promise<void>;
    get: (id: string) => Promise<MarketMetrics | null>;
  };
}

interface Agent {
  id: string;
  walletAddress: string;
  totalListings: number;
  totalPurchases: number;
  totalVolume: bigint;
  lastActivity: bigint;
  chainId: number;
  createdAt: bigint;
}

interface AgentUpdate {
  id: string;
  walletAddress?: string;
  totalListings?: number | ((agent: Agent | null) => number);
  totalPurchases?: number | ((agent: Agent | null) => number);
  totalVolume?: bigint | ((agent: Agent | null) => bigint);
  lastActivity?: bigint;
  chainId?: number;
  createdAt?: bigint | ((agent: Agent | null) => bigint);
}

interface ListingEventData {
  id: string;
  listingId: string;
  type: string;
  agentId: string;
  seller: string;
  price: bigint;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface PurchaseEventData {
  id: string;
  listingId: string;
  buyer: string;
  seller: string;
  amount: bigint;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface MarketplaceFeeEventData {
  id: string;
  oldFee: number;
  newFee: number;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface FundsWithdrawnEventData {
  id: string;
  recipient: string;
  amount: bigint;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface MarketMetrics {
  id: string;
  totalListings: number;
  totalVolume: bigint;
  activeAgents24h: number;
  averagePrice: bigint;
  totalTransactions: number;
  marketplaceFee: number;
  lastUpdated: bigint;
}

interface MarketMetricsUpdate {
  id: string;
  totalListings?: number | ((metrics: MarketMetrics | null) => number);
  totalVolume?: bigint | ((metrics: MarketMetrics | null) => bigint);
  activeAgents24h?: number | ((metrics: MarketMetrics | null) => number);
  averagePrice?: bigint | ((metrics: MarketMetrics | null) => bigint);
  totalTransactions?: number | ((metrics: MarketMetrics | null) => number);
  marketplaceFee?: number | ((metrics: MarketMetrics | null) => number);
  lastUpdated?: bigint;
}

interface ListingCreatedParams {
  listingId: string;
  seller: string;
  price: string;
  timestamp: number;
}

interface ListingPurchasedParams {
  listingId: string;
  buyer: string;
  seller: string;
  price: string;
}

interface MarketplaceFeeUpdatedParams {
  oldFee: string;
  newFee: string;
}

interface FundsWithdrawnParams {
  recipient: string;
  amount: string;
}

interface Event<T> {
  params: T;
  transactionHash: string;
  blockNumber: bigint;
  timestamp: bigint;
  chainId: number;
}

/**
 * Handle ListingCreated event
 * NO aiProofHash - removed per requirements
 */
export async function handleListingCreated(
  event: Event<ListingCreatedParams>,
  context: EventContext,
) {
  const { listingId, seller, price } = event.params;
  const priceBigInt = BigInt(price);

  logger.info(
    {
      listingId,
      seller,
      price: price.toString(),
      blockNumber: event.blockNumber.toString(),
    },
    'Processing ListingCreated event',
  );

  try {
    // Get existing agent or create new one
    const existingAgent = await context.Agent.get(seller);

    // Update or create agent
    await context.Agent.upsert({
      id: seller,
      walletAddress: seller,
      totalListings: existingAgent ? existingAgent.totalListings + 1 : 1,
      totalVolume: existingAgent
        ? existingAgent.totalVolume + priceBigInt
        : priceBigInt,
      lastActivity: event.timestamp,
      chainId: event.chainId,
      createdAt: existingAgent?.createdAt || event.timestamp,
    });

    // Create listing event record
    await context.ListingEvent.create({
      id: `${event.transactionHash}-${event.chainId}`,
      listingId,
      type: 'CREATED',
      agentId: seller,
      seller,
      price: priceBigInt,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    // Update global metrics
    await updateMarketMetrics(context, {
      newListing: true,
      price: priceBigInt,
      timestamp: event.timestamp,
    });

    logger.debug({ listingId }, 'ListingCreated event processed successfully');
  } catch (error) {
    logger.error({ err: error, listingId }, 'Failed to process ListingCreated event');
    throw error;
  }
}

/**
 * Handle ListingPurchased event
 */
export async function handleListingPurchased(
  event: Event<ListingPurchasedParams>,
  context: EventContext,
) {
  const { listingId, buyer, seller, price } = event.params;
  const priceBigInt = BigInt(price);

  logger.info(
    {
      listingId,
      buyer,
      seller,
      price: price.toString(),
      txHash: event.transactionHash,
    },
    'Processing ListingPurchased event',
  );

  try {
    // Update buyer agent
    if (buyer) {
      const existingBuyer = await context.Agent.get(buyer);
      await context.Agent.upsert({
        id: buyer,
        walletAddress: buyer,
        totalPurchases: existingBuyer ? existingBuyer.totalPurchases + 1 : 1,
        totalVolume: existingBuyer
          ? existingBuyer.totalVolume + priceBigInt
          : priceBigInt,
        lastActivity: event.timestamp,
        chainId: event.chainId,
        createdAt: existingBuyer?.createdAt || event.timestamp,
      });
    }

    // Update seller agent
    const existingSeller = await context.Agent.get(seller);
    await context.Agent.upsert({
      id: seller,
      walletAddress: seller,
      lastActivity: event.timestamp,
      chainId: event.chainId,
      createdAt: existingSeller?.createdAt || event.timestamp,
    });

    // Create purchase event record
    await context.PurchaseEvent.create({
      id: `${event.transactionHash}-${event.chainId}`,
      listingId,
      buyer,
      seller,
      amount: priceBigInt,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    // Update global metrics
    await updateMarketMetrics(context, {
      newPurchase: true,
      price: priceBigInt,
      timestamp: event.timestamp,
    });

    logger.debug(
      { listingId, txHash: event.transactionHash },
      'ListingPurchased event processed',
    );
  } catch (error) {
    logger.error(
      { err: error, listingId },
      'Failed to process ListingPurchased event',
    );
    throw error;
  }
}

/**
 * Handle MarketplaceFeeUpdated event
 */
export async function handleMarketplaceFeeUpdated(
  event: Event<MarketplaceFeeUpdatedParams>,
  context: EventContext,
) {
  const { oldFee, newFee } = event.params;
  const oldFeeInt = parseInt(oldFee);
  const newFeeInt = parseInt(newFee);

  logger.info(
    {
      oldFee,
      newFee,
      txHash: event.transactionHash,
    },
    'Processing MarketplaceFeeUpdated event',
  );

  try {
    // Create fee update event record
    await context.MarketplaceFeeEvent.create({
      id: `${event.transactionHash}-${event.chainId}`,
      oldFee: oldFeeInt,
      newFee: newFeeInt,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    // Update global metrics with new fee
    await updateMarketMetrics(context, {
      newMarketplaceFee: newFeeInt,
      timestamp: event.timestamp,
    });

    logger.debug({ oldFee, newFee }, 'MarketplaceFeeUpdated event processed');
  } catch (error) {
    logger.error({ err: error }, 'Failed to process MarketplaceFeeUpdated event');
    throw error;
  }
}

/**
 * Handle FundsWithdrawn event
 */
export async function handleFundsWithdrawn(
  event: Event<FundsWithdrawnParams>,
  context: EventContext,
) {
  const { recipient, amount } = event.params;
  const amountBigInt = BigInt(amount);

  logger.info(
    {
      recipient,
      amount,
      txHash: event.transactionHash,
    },
    'Processing FundsWithdrawn event',
  );

  try {
    // Create withdrawal event record
    await context.FundsWithdrawnEvent.create({
      id: `${event.transactionHash}-${event.chainId}`,
      recipient,
      amount: amountBigInt,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    logger.debug({ recipient, amount: amount.toString() }, 'FundsWithdrawn event processed');
  } catch (error) {
    logger.error({ err: error }, 'Failed to process FundsWithdrawn event');
    throw error;
  }
}

/**
 * Update global market metrics
 */
async function updateMarketMetrics(
  context: EventContext,
  update: {
    newListing?: boolean;
    newPurchase?: boolean;
    price?: bigint;
    newMarketplaceFee?: number;
    timestamp: bigint;
  },
) {
  try {
    const metrics = await context.MarketMetrics.get('global');

    const currentMetrics = metrics || {
      id: 'global',
      totalListings: 0,
      totalVolume: BigInt(0),
      activeAgents24h: 0,
      averagePrice: BigInt(0),
      totalTransactions: 0,
      marketplaceFee: 0,
      lastUpdated: BigInt(0),
    };

    await context.MarketMetrics.upsert({
      id: 'global',
      totalListings: update.newListing
        ? currentMetrics.totalListings + 1
        : currentMetrics.totalListings,
      totalTransactions: update.newPurchase
        ? currentMetrics.totalTransactions + 1
        : currentMetrics.totalTransactions,
      totalVolume: update.price
        ? currentMetrics.totalVolume + update.price
        : currentMetrics.totalVolume,
      marketplaceFee: update.newMarketplaceFee !== undefined
        ? update.newMarketplaceFee
        : currentMetrics.marketplaceFee,
      lastUpdated: update.timestamp,
    });

    logger.debug('Market metrics updated');
  } catch (error) {
    logger.error({ err: error }, 'Failed to update market metrics');
  }
}

// Export handlers for Envio
export const VerifiableMarketplace = {
  ListingCreated: {
    handler: handleListingCreated,
  },
  ListingPurchased: {
    handler: handleListingPurchased,
  },
  MarketplaceFeeUpdated: {
    handler: handleMarketplaceFeeUpdated,
  },
  FundsWithdrawn: {
    handler: handleFundsWithdrawn,
  },
};
