import { loggers } from '../../src/lib/utils/logger';

const logger = loggers.envio;

// Event handler types (these would be generated by Envio)
interface EventContext {
  Agent: {
    upsert: (data: any) => Promise<void>;
    get: (id: string) => Promise<any>;
  };
  Listing: {
    create: (data: any) => Promise<void>;
    update: (id: string, data: any) => Promise<void>;
  };
  Transaction: {
    create: (data: any) => Promise<void>;
  };
  MarketMetrics: {
    upsert: (data: any) => Promise<void>;
    get: (id: string) => Promise<any>;
  };
}

interface EventParams {
  listingId: string;
  seller: string;
  buyer?: string;
  price: bigint;
  aiProofHash?: string;
}

interface Event {
  params: EventParams;
  transactionHash: string;
  blockNumber: bigint;
  timestamp: bigint;
  chainId: number;
}

/**
 * Handle ListingCreated event
 */
export async function handleListingCreated(event: Event, context: EventContext) {
  const { listingId, seller, price, aiProofHash } = event.params;

  logger.info(
    { listingId, seller, price: price.toString(), blockNumber: event.blockNumber.toString() },
    'Processing ListingCreated event'
  );

  try {
    // Update or create agent
    await context.Agent.upsert({
      id: seller,
      walletAddress: seller,
      totalListings: async (agent: any) => (agent?.totalListings || 0n) + 1n,
      totalVolume: async (agent: any) => (agent?.totalVolume || 0n) + price,
      lastActivity: event.timestamp,
      createdAt: async (agent: any) => agent?.createdAt || event.timestamp,
    });

    // Create listing record
    await context.Listing.create({
      id: `${listingId}-${event.chainId}`,
      listingId,
      seller,
      price,
      sold: false,
      aiProofHash: aiProofHash || '0x',
      createdAt: event.timestamp,
    });

    // Update global metrics
    await updateMarketMetrics(context, {
      newListing: true,
      price,
      timestamp: event.timestamp,
    });

    logger.debug({ listingId }, 'ListingCreated event processed successfully');
  } catch (error) {
    logger.error({ err: error, listingId }, 'Failed to process ListingCreated event');
    throw error;
  }
}

/**
 * Handle ListingPurchased event
 */
export async function handleListingPurchased(event: Event, context: EventContext) {
  const { listingId, buyer, seller, price } = event.params;

  logger.info(
    {
      listingId,
      buyer,
      seller,
      price: price.toString(),
      txHash: event.transactionHash
    },
    'Processing ListingPurchased event'
  );

  try {
    // Update buyer agent
    if (buyer) {
      await context.Agent.upsert({
        id: buyer,
        walletAddress: buyer,
        totalPurchases: async (agent: any) => (agent?.totalPurchases || 0n) + 1n,
        totalVolume: async (agent: any) => (agent?.totalVolume || 0n) + price,
        lastActivity: event.timestamp,
        createdAt: async (agent: any) => agent?.createdAt || event.timestamp,
      });
    }

    // Update seller agent
    await context.Agent.upsert({
      id: seller,
      walletAddress: seller,
      lastActivity: event.timestamp,
    });

    // Update listing
    await context.Listing.update(`${listingId}-${event.chainId}`, {
      sold: true,
      buyer,
      soldAt: event.timestamp,
    });

    // Create transaction record
    await context.Transaction.create({
      id: event.transactionHash,
      hash: event.transactionHash,
      from: buyer || '0x0',
      to: seller,
      listing: `${listingId}-${event.chainId}`,
      amount: price,
      timestamp: event.timestamp,
      blockNumber: event.blockNumber,
    });

    // Update global metrics
    await updateMarketMetrics(context, {
      newPurchase: true,
      price,
      timestamp: event.timestamp,
    });

    logger.debug({ listingId, txHash: event.transactionHash }, 'ListingPurchased event processed');
  } catch (error) {
    logger.error({ err: error, listingId }, 'Failed to process ListingPurchased event');
    throw error;
  }
}

/**
 * Handle MarketplaceFeeUpdated event
 */
export async function handleMarketplaceFeeUpdated(event: any, context: EventContext) {
  const { oldFee, newFee } = event.params;

  logger.info(
    { oldFee: oldFee.toString(), newFee: newFee.toString() },
    'Processing MarketplaceFeeUpdated event'
  );

  // Could store fee history if needed
  await updateMarketMetrics(context, {
    feeUpdate: { old: oldFee, new: newFee },
    timestamp: event.timestamp,
  });
}

/**
 * Update global market metrics
 */
async function updateMarketMetrics(
  context: EventContext,
  update: {
    newListing?: boolean;
    newPurchase?: boolean;
    price?: bigint;
    feeUpdate?: any;
    timestamp: bigint;
  }
) {
  try {
    const metrics = await context.MarketMetrics.get('global') || {
      id: 'global',
      totalListings: 0n,
      totalVolume: 0n,
      totalAgents: 0n,
      activeAgents24h: 0n,
      averagePrice: 0n,
    };

    await context.MarketMetrics.upsert({
      id: 'global',
      totalListings: update.newListing
        ? metrics.totalListings + 1n
        : metrics.totalListings,
      totalVolume: update.price
        ? metrics.totalVolume + update.price
        : metrics.totalVolume,
      updatedAt: update.timestamp,
    });

    logger.debug('Market metrics updated');
  } catch (error) {
    logger.error({ err: error }, 'Failed to update market metrics');
  }
}

// Export handlers for Envio
export const VerifiableMarketplace = {
  ListingCreated: {
    handler: handleListingCreated,
  },
  ListingPurchased: {
    handler: handleListingPurchased,
  },
  MarketplaceFeeUpdated: {
    handler: handleMarketplaceFeeUpdated,
  },
};