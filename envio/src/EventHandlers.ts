import { loggers } from '../../src/lib/utils/logger';

const logger = loggers.envio;

// Event handler types (these would be generated by Envio)
interface EventContext {
  Agent: {
    upsert: (data: AgentUpdate) => Promise<void>;
    get: (id: string) => Promise<Agent | null>;
  };
  ListingEvent: {
    create: (data: ListingEventData) => Promise<void>;
  };
  PurchaseEvent: {
    create: (data: PurchaseEventData) => Promise<void>;
  };
  AgentRegistration: {
    create: (data: AgentRegistrationData) => Promise<void>;
  };
  MarketMetrics: {
    upsert: (data: MarketMetricsUpdate) => Promise<void>;
    get: (id: string) => Promise<MarketMetrics | null>;
  };
}

interface Agent {
  id: string;
  walletAddress: string;
  totalListings: number;
  totalPurchases: number;
  totalVolume: bigint;
  lastActivity: bigint;
  chainId: number;
  createdAt: bigint;
}

interface AgentUpdate {
  id: string;
  walletAddress?: string;
  totalListings?: number | ((agent: Agent | null) => number);
  totalPurchases?: number | ((agent: Agent | null) => number);
  totalVolume?: bigint | ((agent: Agent | null) => bigint);
  lastActivity?: bigint;
  chainId?: number;
  createdAt?: bigint | ((agent: Agent | null) => bigint);
}

interface ListingEventData {
  id: string;
  listingId: string;
  type: string;
  agentId: string;
  seller: string;
  price: bigint;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface PurchaseEventData {
  id: string;
  listingId: string;
  buyer: string;
  seller: string;
  amount: bigint;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface AgentRegistrationData {
  id: string;
  agentId: string;
  walletAddress: string;
  timestamp: bigint;
  chainId: number;
  transactionHash: string;
  blockNumber: bigint;
}

interface MarketMetrics {
  id: string;
  totalListings: number;
  totalVolume: bigint;
  activeAgents24h: number;
  averagePrice: bigint;
  totalTransactions: number;
  lastUpdated: bigint;
}

interface MarketMetricsUpdate {
  id: string;
  totalListings?: number | ((metrics: MarketMetrics | null) => number);
  totalVolume?: bigint | ((metrics: MarketMetrics | null) => bigint);
  activeAgents24h?: number | ((metrics: MarketMetrics | null) => number);
  averagePrice?: bigint | ((metrics: MarketMetrics | null) => bigint);
  totalTransactions?: number | ((metrics: MarketMetrics | null) => number);
  lastUpdated?: bigint;
}

interface ListingCreatedParams {
  listingId: string;
  seller: string;
  price: string;
  timestamp: number;
}

interface PurchaseInitiatedParams {
  listingId: string;
  buyer: string;
  seller: string;
  amount: string;
  timestamp: number;
}

interface AgentRegisteredParams {
  agentId: string;
  walletAddress: string;
  timestamp: number;
}

interface Event<T> {
  params: T;
  transactionHash: string;
  blockNumber: bigint;
  timestamp: bigint;
  chainId: number;
}

/**
 * Handle ListingCreated event
 * NO aiProofHash - removed per requirements
 */
export async function handleListingCreated(
  event: Event<ListingCreatedParams>,
  context: EventContext,
) {
  const { listingId, seller, price } = event.params;
  const priceBigInt = BigInt(price);

  logger.info(
    {
      listingId,
      seller,
      price: price.toString(),
      blockNumber: event.blockNumber.toString(),
    },
    'Processing ListingCreated event',
  );

  try {
    // Get existing agent or create new one
    const existingAgent = await context.Agent.get(seller);

    // Update or create agent
    await context.Agent.upsert({
      id: seller,
      walletAddress: seller,
      totalListings: existingAgent ? existingAgent.totalListings + 1 : 1,
      totalVolume: existingAgent
        ? existingAgent.totalVolume + priceBigInt
        : priceBigInt,
      lastActivity: event.timestamp,
      chainId: event.chainId,
      createdAt: existingAgent?.createdAt || event.timestamp,
    });

    // Create listing event record
    await context.ListingEvent.create({
      id: `${event.transactionHash}-${event.chainId}`,
      listingId,
      type: 'CREATED',
      agentId: seller,
      seller,
      price: priceBigInt,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    // Update global metrics
    await updateMarketMetrics(context, {
      newListing: true,
      price: priceBigInt,
      timestamp: event.timestamp,
    });

    logger.debug({ listingId }, 'ListingCreated event processed successfully');
  } catch (error) {
    logger.error({ err: error, listingId }, 'Failed to process ListingCreated event');
    throw error;
  }
}

/**
 * Handle PurchaseInitiated event
 */
export async function handlePurchaseInitiated(
  event: Event<PurchaseInitiatedParams>,
  context: EventContext,
) {
  const { listingId, buyer, seller, amount } = event.params;
  const amountBigInt = BigInt(amount);

  logger.info(
    {
      listingId,
      buyer,
      seller,
      amount: amount.toString(),
      txHash: event.transactionHash,
    },
    'Processing PurchaseInitiated event',
  );

  try {
    // Update buyer agent
    if (buyer) {
      const existingBuyer = await context.Agent.get(buyer);
      await context.Agent.upsert({
        id: buyer,
        walletAddress: buyer,
        totalPurchases: existingBuyer ? existingBuyer.totalPurchases + 1 : 1,
        totalVolume: existingBuyer
          ? existingBuyer.totalVolume + amountBigInt
          : amountBigInt,
        lastActivity: event.timestamp,
        chainId: event.chainId,
        createdAt: existingBuyer?.createdAt || event.timestamp,
      });
    }

    // Update seller agent
    const existingSeller = await context.Agent.get(seller);
    await context.Agent.upsert({
      id: seller,
      walletAddress: seller,
      lastActivity: event.timestamp,
      chainId: event.chainId,
      createdAt: existingSeller?.createdAt || event.timestamp,
    });

    // Create purchase event record
    await context.PurchaseEvent.create({
      id: `${event.transactionHash}-${event.chainId}`,
      listingId,
      buyer,
      seller,
      amount: amountBigInt,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    // Update global metrics
    await updateMarketMetrics(context, {
      newPurchase: true,
      price: amountBigInt,
      timestamp: event.timestamp,
    });

    logger.debug(
      { listingId, txHash: event.transactionHash },
      'PurchaseInitiated event processed',
    );
  } catch (error) {
    logger.error(
      { err: error, listingId },
      'Failed to process PurchaseInitiated event',
    );
    throw error;
  }
}

/**
 * Handle AgentRegistered event
 */
export async function handleAgentRegistered(
  event: Event<AgentRegisteredParams>,
  context: EventContext,
) {
  const { agentId, walletAddress } = event.params;

  logger.info(
    {
      agentId,
      walletAddress,
      txHash: event.transactionHash,
    },
    'Processing AgentRegistered event',
  );

  try {
    // Create or update agent
    await context.Agent.upsert({
      id: agentId,
      walletAddress,
      totalListings: 0,
      totalPurchases: 0,
      totalVolume: BigInt(0),
      lastActivity: event.timestamp,
      chainId: event.chainId,
      createdAt: event.timestamp,
    });

    // Create registration record
    await context.AgentRegistration.create({
      id: `${event.transactionHash}-${event.chainId}`,
      agentId,
      walletAddress,
      timestamp: event.timestamp,
      chainId: event.chainId,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber,
    });

    logger.debug({ agentId }, 'AgentRegistered event processed successfully');
  } catch (error) {
    logger.error({ err: error, agentId }, 'Failed to process AgentRegistered event');
    throw error;
  }
}

/**
 * Update global market metrics
 */
async function updateMarketMetrics(
  context: EventContext,
  update: {
    newListing?: boolean;
    newPurchase?: boolean;
    price?: bigint;
    timestamp: bigint;
  },
) {
  try {
    const metrics = await context.MarketMetrics.get('global');

    const currentMetrics = metrics || {
      id: 'global',
      totalListings: 0,
      totalVolume: BigInt(0),
      activeAgents24h: 0,
      averagePrice: BigInt(0),
      totalTransactions: 0,
      lastUpdated: BigInt(0),
    };

    await context.MarketMetrics.upsert({
      id: 'global',
      totalListings: update.newListing
        ? currentMetrics.totalListings + 1
        : currentMetrics.totalListings,
      totalTransactions: update.newPurchase
        ? currentMetrics.totalTransactions + 1
        : currentMetrics.totalTransactions,
      totalVolume: update.price
        ? currentMetrics.totalVolume + update.price
        : currentMetrics.totalVolume,
      lastUpdated: update.timestamp,
    });

    logger.debug('Market metrics updated');
  } catch (error) {
    logger.error({ err: error }, 'Failed to update market metrics');
  }
}

// Export handlers for Envio
export const VerifiableMarketplace = {
  ListingCreated: {
    handler: handleListingCreated,
  },
  PurchaseInitiated: {
    handler: handlePurchaseInitiated,
  },
  AgentRegistered: {
    handler: handleAgentRegistered,
  },
};
